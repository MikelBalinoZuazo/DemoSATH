<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Digital Twin - Modelo SATH</title>
    
    <style>
        html, body {
            overflow: hidden; /* Evita scroll de la página */
            margin: 0;
            padding: 0;
            height: 100%; /* El canvas ocupará toda la altura */
            width: 100%;
            font-family: sans-serif;
            background-color: #f0f0f0; /* Color de fondo general */
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none; /* Crucial para el control de la cámara en móviles */
        }
        .ui-button {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.6);
            color: white;
            border: none;
            padding: 10px 15px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            z-index: 10;
        }
        /* Puedes añadir aquí los estilos para el infoPanel si los necesitas más adelante */
        #infoPanel { /* Mismo estilo que antes, pero oculto por defecto */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 25px;
            border-radius: 10px;
            font-size: 1.1em;
            display: none; /* Oculto por defecto */
            z-index: 100;
            max-width: 450px;
            text-align: center;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
        }
        #infoPanel h3 {
            margin-top: 0;
            color: #72E06E;
            font-size: 1.6em;
            margin-bottom: 15px;
        }
        #infoPanel p {
            line-height: 1.6;
            margin-bottom: 20px;
        }
        #closeInfo {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: white;
            font-size: 1.8em;
            cursor: pointer;
        }
        #closeInfo:hover {
            color: #FF6B6B;
        }
    </style>
</head>
<body>

    <canvas id="renderCanvas"></canvas>

    <button class="ui-button" onclick="resetCamera()">Reset View</button>

    <div id="infoPanel">
        <button id="closeInfo">X</button>
        <h3 id="panelTitle"></h3>
        <p id="panelContent"></p>
    </div>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script>
        // --- Variables globales para Babylon.js y la cámara ---
        let camera; // Declarar la cámara globalmente para que resetCamera pueda acceder a ella
        let initialAlpha, initialBeta, initialRadius, initialTarget; // Variables para el reset

        // --- Función para resetear la cámara ---
        // DEBE ESTAR DEFINIDA ANTES DE QUE EL BOTÓN intente llamarla
        function resetCamera() {
            // Solo resetear si los valores iniciales ya se han capturado
            if (initialTarget) {
                camera.setTarget(initialTarget);
                camera.alpha = initialAlpha;
                camera.beta = initialBeta;
                camera.radius = initialRadius;
            } else {
                console.warn("La cámara aún no ha sido inicializada. Espera a que el modelo cargue.");
            }
        }

        // --- Configuración e inicialización de Babylon.js ---
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        const scene = new BABYLON.Scene(engine);

        // Color de fondo de la escena
        scene.clearColor = new BABYLON.Color3(0.7, 0.8, 0.9);

        // Crear la cámara ArcRotateCamera
        camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 2, Math.PI / 2.5, 10, BABYLON.Vector3.Zero(), scene);
        camera.attachControl(canvas, true);

        // Configurar límites de zoom más amplios para la cámara
        camera.upperRadiusLimit = 5000; // Permite alejarse mucho
        camera.lowerRadiusLimit = 0.1;  // Permite acercarse mucho
        camera.wheelPrecision = 0.5;    // Ajusta la sensibilidad del zoom

        // Luces para iluminar la escena
        const light = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(0, 1, 0), scene);
        light.intensity = 0.7; // Intensidad de la luz ambiental

        const dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(0, -1, 1), scene);
        dirLight.intensity = 0.3; // Intensidad de la luz direccional

        // Evitar el scroll de la página al usar la rueda del ratón sobre el canvas
        canvas.addEventListener("wheel", function (event) {
            event.preventDefault();
        }, { passive: false });

        // --- Carga del Modelo 3D (GLB) ---
        // Este bloque se ejecuta cuando el modelo 'modelo.glb' se ha cargado
        BABYLON.SceneLoader.Append("./", "modelo.glb", scene, (loadedMeshes, particleSystems, skeletons, animationGroups) => {
            console.log("Modelo 'modelo.glb' cargado con éxito.");

            // **Esta línea es la clave para que la cámara se ajuste y veas el modelo.**
            // Asegura que tu cámara 'camera' es la activa y la ajusta al modelo.
            scene.activeCamera = camera; // Asegurarse de que nuestra cámara es la activa
            scene.createDefaultCameraOrLight(true, true, true); // Ajusta la cámara activa y crea luces/suelo si es necesario

            // Ahora que la cámara se ha ajustado automáticamente para ver el modelo,
            // guardamos sus valores actuales como "iniciales" para el botón de reset.
            initialAlpha = camera.alpha;
            initialBeta = camera.beta;
            initialRadius = camera.radius;
            initialTarget = camera.target.clone(); // Clona el vector para no tener una referencia directa

            // Opcional: Asignar un material blanco a todas las mallas del modelo
            // Elimina este forEach si quieres usar los materiales originales de tu GLB
            scene.meshes.forEach(mesh => {
                if (mesh.material) {
                    const whiteMaterial = new BABYLON.StandardMaterial("whiteMat", scene);
                    whiteMaterial.diffuseColor = new BABYLON.Color3(1, 1, 1);
                    mesh.material = whiteMaterial;
                }
            });

            // --- Lógica para Hotspots / Interacciones ---
            // Asegúrate de que este bloque de código está completo con todas sus llaves de cierre.
            // Para encontrar los nombres correctos de tus mallas, usa el Inspector (descomenta la línea de abajo).
            // Ejemplo de obtención de mallas por nombre (¡CAMBIA LOS NOMBRES!)
            const hotspotMesh_A = scene.getMeshByName("nombre_de_tu_malla_1"); // Por ejemplo, "BaseTurbine"
            const hotspotMesh_B = scene.getMeshByName("nombre_de_tu_malla_2"); // Por ejemplo, "Blade_R"

            // Crear materiales de resaltado para los hotspots
            const highlightMaterialA = new BABYLON.StandardMaterial("highlightMatA", scene);
            highlightMaterialA.diffuseColor = new BABYLON.Color3(0, 1, 0); // Verde

            const highlightMaterialB = new BABYLON.StandardMaterial("highlightMatB", scene);
            highlightMaterialB.diffuseColor = new BABYLON.Color3(1, 0.5, 0); // Naranja

            // Habilitar un ActionManager para detectar eventos de clic y hover
            scene.actionManager = new BABYLON.ActionManager(scene);

            // Función para mostrar el panel de información del hotspot
            const infoPanel = document.getElementById("infoPanel");
            const panelTitle = document.getElementById("panelTitle");
            const panelContent = document.getElementById("panelContent");
            const closeInfoButton = document.getElementById("closeInfo");

            // Asegúrate de que el botón de cerrar funciona
            if (closeInfoButton) {
                closeInfoButton.onclick = function() {
                    if (infoPanel) infoPanel.style.display = "none";
                };
            }

            function showInfoPanel(title, content) {
                if (panelTitle && panelContent && infoPanel) {
                    panelTitle.innerText = title;
                    panelContent.innerText = content;
                    infoPanel.style.display = "block";
                }
            }

            // Configurar interacciones para hotspotMesh_A
            if (hotspotMesh_A) {
                scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPickTrigger,
                    function (evt) {
                        if (evt.meshClicked === hotspotMesh_A) {
                            showInfoPanel("Sección Principal del SATH", "Esta es la sección de control principal del SATH. Monitoriza los sistemas críticos y la generación de energía.");
                        }
                    }
                ));
                scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPointerOverTrigger,
                    function (evt) {
                        if (evt.meshUnderPointer === hotspotMesh_A) {
                            hotspotMesh_A._originalMaterial = hotspotMesh_A.material;
                            hotspotMesh_A.material = highlightMaterialA;
                            canvas.style.cursor = "pointer";
                        }
                    }
                ));
                scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPointerOutTrigger,
                    function (evt) {
                        if (evt.meshUnderPointer === hotspotMesh_A && hotspotMesh_A._originalMaterial) {
                            hotspotMesh_A.material = hotspotMesh_A._originalMaterial;
                            canvas.style.cursor = "grab";
                        }
                    }
                ));
            } else {
                console.warn("Hotspot 'nombre_de_tu_malla_1' no encontrado. Revisa el nombre en el GLB.");
            }

            // Configurar interacciones para hotspotMesh_B
            if (hotspotMesh_B) {
                scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPickTrigger,
                    function (evt) {
                        if (evt.meshClicked === hotspotMesh_B) {
                            showInfoPanel("Palas de Turbina", "Las palas están diseñadas para capturar la energía del viento de manera eficiente y convertirla en rotación.");
                        }
                    }
                ));
                scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPointerOverTrigger,
                    function (evt) {
                        if (evt.meshUnderPointer === hotspotMesh_B) {
                            hotspotMesh_B._originalMaterial = hotspotMesh_B.material;
                            hotspotMesh_B.material = highlightMaterialB;
                            canvas.style.cursor = "pointer";
                        }
                    }
                ));
                scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPointerOutTrigger,
                    function (evt) {
                        if (evt.meshUnderPointer === hotspotMesh_B && hotspotMesh_B._originalMaterial) {
                            hotspotMesh_B.material = hotspotMesh_B._originalMaterial;
                            canvas.style.cursor = "grab";
                        }
                    }
                ));
            } else {
                console.warn("Hotspot 'nombre_de_tu_malla_2' no encontrado. Revisa el nombre en el GLB.");
            }

            // Opcional: Activar el Inspector de Babylon.js (¡SOLO PARA DESARROLLO!)
            // Descomenta la siguiente línea y la inclusión del script del inspector en el <head>
            // (<script src="https://cdn.babylonjs.com/inspector/babylon.inspector.min.js"></script>)
            // para usarlo. Coméntala o quítala antes de subir a producción.
            // scene.debugLayer.show();

        }, null, (scene, message, exception) => {
            // Callback de error de carga del modelo
            console.error("Error al cargar el modelo GLB:", message, exception);
        });

        // --- Bucle principal de renderizado de Babylon.js ---
        engine.runRenderLoop(() => {
            scene.render();
        });

        // --- Manejo del redimensionamiento de la ventana ---
        window.addEventListener("resize", () => {
            engine.resize();
        });
    </script>

</body>
</html>
